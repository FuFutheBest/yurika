---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localGamesList from "../data/games";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// æ£€æŸ¥æ¸¸æˆé¡µé¢æ˜¯å¦å¯ç”¨
if (!siteConfig.featurePages.games) {
	return Astro.redirect("/404/");
}

// Bangumi APIé…ç½®
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BANGUMI_API_BASE = "https://api.bgm.tv";

// è·å–æ¸¸æˆæ•°æ®æ¨¡å¼
const GAMES_MODE = siteConfig.games?.mode || "bangumi";

// æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¾§è¾¹æ æ¨¡å¼
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// ç±»å‹å®šä¹‰ä»¥é¿å…ä½¿ç”¨ any
type BangumiPerson = { relation: string; name?: string };
type BangumiTag = { name: string };
type BangumiSubject = {
  id: number;
  name?: string;
  name_cn?: string;
  images?: { medium?: string };
  short_summary?: string;
  eps?: number;
  tags?: BangumiTag[];
  date?: string;
  platform?: string;
};
type BangumiCollectionItem = {
  subject_id: number;
  subject?: BangumiSubject;
  rate?: number;
  ep_status?: number;
};
type BangumiCollectionResponse = { data: BangumiCollectionItem[] };

// è·å–å•ä¸ªæ¡ç›®ç›¸å…³äººå‘˜ä¿¡æ¯
async function fetchSubjectPersons(subjectId: number): Promise<BangumiPerson[]> {
	try {
		const response = await fetch(
			`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
		);
		const data = await response.json();
		return Array.isArray(data) ? data : [];
	} catch (error) {
		console.error(`Error fetching subject ${subjectId} persons:`, error);
		return [];
	}
}

// è·å–Bangumiæ”¶è—åˆ—è¡¨
async function fetchBangumiCollection(
	userId: string,
	subjectType: number,
	type: number,
): Promise<BangumiCollectionResponse | null> {
	try {
    let allData: BangumiCollectionItem[] = [];
		let offset = 0;
		const limit = 50;
		let hasMore = true;

		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
			);
			if (!response.ok) {
				throw new Error(`Bangumi API error: ${response.status}`);
			}
			const data = await response.json();

			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) {
				hasMore = false;
			} else {
				offset += limit;
			}
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
    return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

// è·å–Bangumiæ•°æ®è½¬æ¢ä¸ºé¡µé¢æ‰€éœ€æ ¼å¼
import type { GameItem } from "../data/games";

async function processBangumiData(
  data: BangumiCollectionResponse,
  status: GameItem["status"],
): Promise<GameItem[]> {
	if (!data || !data.data) return [];

  const detailedItems: GameItem[] = await Promise.all(
    data.data.map(async (item: BangumiCollectionItem) => {
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			const year = item.subject?.date || "Unknown";
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			const progress = item.ep_status || 0;
			const totalProgress = item.subject?.eps || progress || 100;

			let developer = "Unknown";
			if (Array.isArray(subjectPersons)) {
				const priorities = ["å¼€å‘", "é–‹ç™º", "åˆ¶ä½œ", "è£½ä½œ"];
				for (const relation of priorities) {
					const match = subjectPersons.find(
						(person) => person.relation === relation,
					);
					if (match?.name) {
						developer = match.name;
						break;
					}
				}
			}

      return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
        status: status,
				rating: rating,
        cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (
					item.subject?.short_summary ||
					item.subject?.name_cn ||
					""
				).trimStart(),
				platform: item.subject?.platform || "Unknown",
				year: year,
				genre: item.subject?.tags
          ? item.subject.tags.slice(0, 3).map((tag: BangumiTag) => tag.name)
					: ["Unknown"],
				developer: developer,
        link: item.subject?.id ? `https://bgm.tv/subject/${item.subject.id}` : "#",
				progress: progress,
				totalProgress: totalProgress,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			};
		}),
	);
	return detailedItems;
}

// æ ¹æ®æ¨¡å¼è·å–æ¸¸æˆåˆ—è¡¨
let gamesList: typeof localGamesList = [];
if (GAMES_MODE === "local") {
	gamesList = localGamesList;
} else {
	// ä½¿ç”¨Bangumi APIï¼ŒsubjectType=4 ä»£è¡¨æ¸¸æˆ
  const playingData = await fetchBangumiCollection(BANGUMI_USER_ID, 4, 3);
  const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 4, 2);
  const plannedData = await fetchBangumiCollection(BANGUMI_USER_ID, 4, 1);
  const onHoldData = await fetchBangumiCollection(BANGUMI_USER_ID, 4, 4);
  const droppedData = await fetchBangumiCollection(BANGUMI_USER_ID, 4, 5);

	const playingList = playingData
		? await processBangumiData(playingData, "playing")
		: [];
	const completedList = completedData
		? await processBangumiData(completedData, "completed")
		: [];
	const plannedList = plannedData
		? await processBangumiData(plannedData, "planned")
		: [];
  const onHoldList = onHoldData
    ? await processBangumiData(onHoldData, "onhold")
    : [];
  const droppedList = droppedData
    ? await processBangumiData(droppedData, "dropped")
    : [];

  gamesList = [
    ...playingList,
    ...plannedList,
    ...completedList,
    ...onHoldList,
    ...droppedList,
  ];
}

// è·å–çŠ¶æ€çš„ç¿»è¯‘æ–‡æœ¬å’Œæ ·å¼
function getStatusInfo(status: string) {
	switch (status) {
		case "playing":
			return {
				text: i18n(I18nKey.gamesStatusPlaying),
				class:
					"bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "ğŸ®",
			};
		case "completed":
			return {
				text: i18n(I18nKey.gamesStatusCompleted),
				class:
					"bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "âœ“",
			};
		case "planned":
			return {
				text: i18n(I18nKey.gamesStatusPlanned),
				class:
					"bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
				icon: "â°",
			};
    case "onhold":
      return {
        text: i18n(I18nKey.gamesStatusOnHold),
        class:
          "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
        icon: "â¸",
      };
    case "dropped":
      return {
        text: i18n(I18nKey.gamesStatusDropped),
        class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
        icon: "âœ—",
      };
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
const stats = {
	total: gamesList.length,
	playing: gamesList.filter((game) => game.status === "playing").length,
	completed: gamesList.filter((game) => game.status === "completed").length,
	avgRating: (() => {
		const ratedGames = gamesList.filter((game) => game.rating > 0);
		if (ratedGames.length === 0) return "0.0";
		return (
			ratedGames.reduce((sum, game) => sum + game.rating, 0) / ratedGames.length
		).toFixed(1);
	})(),
};
---

<MainGridLayout title={i18n(I18nKey.games)} description={i18n(I18nKey.gamesSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.gamesTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.gamesSubtitle)}</p>
        </div>
        
        <!-- è¿‡æ»¤æŒ‰é’® -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">{i18n(I18nKey.gamesFilterAll)}</button>
            <button class="filter-tag" data-status="playing">{i18n(I18nKey.gamesStatusPlaying)}</button>
            <button class="filter-tag" data-status="completed">{i18n(I18nKey.gamesStatusCompleted)}</button>
            <button class="filter-tag" data-status="planned">{i18n(I18nKey.gamesStatusPlanned)}</button>
            {GAMES_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">{i18n(I18nKey.gamesStatusOnHold)}</button>
                <button class="filter-tag" data-status="dropped">{i18n(I18nKey.gamesStatusDropped)}</button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- æ¸¸æˆåˆ—è¡¨ -->
      <div class="mb-8">
        {GAMES_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.gamesEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              è¯·åœ¨ src/config.ts æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ Bangumi ç”¨æˆ·ID
            </p>
          </div>
        ) : gamesList.length > 0 ? (
          <div id="games-list-container" class={`games-grid-container grid gap-4 md:gap-6 list-mode ${
            isBothSidebarMode ? "both-sidebar" : "single-sidebar"
          }`}>
            {gamesList.map(game => {
              const statusInfo = getStatusInfo(game.status);
              const progressPercent = game.totalProgress > 0 ? (game.progress / game.totalProgress) * 100 : 0;
              
              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-game-status={game.status}>
                  <!-- å°é¢åŒºåŸŸ -->
                  <div class="relative aspect-[3/4] overflow-hidden">
                    <a href={game.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={game.cover} 
                        alt={game.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- çŠ¶æ€æ ‡ç­¾ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- è¯„åˆ† -->
                    <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                      <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                      </svg>
                      <span>{game.rating}</span>
                    </div>
                    
                    <!-- è¿›åº¦æ¡ -->
                    {game.status === 'playing' && game.totalProgress > 0 && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-purple-400 to-pink-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">
                          {Math.round(progressPercent)}% å®Œæˆ
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <!-- å†…å®¹åŒºåŸŸ -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{game.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{game.description}</p>
                    
                    <!-- è¯¦ç»†ä¿¡æ¯ -->
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.gamesYear)}</span>
                        <span class="text-black/70 dark:text-white/70">{game.year}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.gamesDeveloper)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{game.developer}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.gamesPlatform)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{game.platform}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {game.genre.map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ˜¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.gamesEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {GAMES_MODE === 'local' ? i18n(I18nKey.gamesEmptyLocal) : i18n(I18nKey.gamesEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ isBothSidebarMode }}>
  // å¸ƒå±€åˆ‡æ¢ä¸åˆ—è¡¨åŠ¨ç”»ï¼ˆä¸ Anime é¡µé¢ä¿æŒä¸€è‡´ï¼‰
  (function() {
    setTimeout(() => {
      const listContainer = document.getElementById("games-list-container");
      if (!listContainer) return;

      if (typeof window.layoutManager !== 'undefined') {
        window.layoutManager.init(isBothSidebarMode);
        const currentLayout = window.layoutManager.getLayout();
        updateGamesListLayout(currentLayout);
        window.layoutManager.checkScreenSizeAndAdjust();
      } else {
        setTimeout(() => {
          if (typeof window.layoutManager !== 'undefined') {
            window.layoutManager.init(isBothSidebarMode);
            const currentLayout = window.layoutManager.getLayout();
            updateGamesListLayout(currentLayout);
            window.layoutManager.checkScreenSizeAndAdjust();
          }
        }, 300);
      }
    }, 50);

    function updateGamesListLayout(layout) {
      const listContainer = document.getElementById("games-list-container");
      if (!listContainer) return;

      const items = Array.from(document.querySelectorAll('[data-game-status]'));
      const firstPositions = new Map();
      items.forEach(item => {
        const rect = item.getBoundingClientRect();
        firstPositions.set(item, { left: rect.left, top: rect.top, width: rect.width, height: rect.height });
      });

      listContainer.classList.remove("list-mode", "grid-mode");
      if (layout === "grid") {
        listContainer.classList.add("grid-mode");
        listContainer.classList.add("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");
        listContainer.classList.remove("flex", "flex-col");

        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) { rightSidebar.style.display = 'none'; rightSidebar.classList.add('hidden-in-grid-mode'); }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) { mainGrid.style.gridTemplateColumns = '17.5rem 1fr'; mainGrid.classList.add('two-column-layout'); mainGrid.setAttribute('data-layout-mode', 'grid'); }
      } else {
        listContainer.classList.add("list-mode");
        listContainer.classList.add("flex", "flex-col");
        listContainer.classList.remove("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");

        const rightSidebar = document.querySelector('.right-sidebar-container');
        if (rightSidebar) { rightSidebar.style.display = ''; rightSidebar.classList.remove('hidden-in-grid-mode'); }
        const mainGrid = document.getElementById('main-grid');
        if (mainGrid) { mainGrid.style.gridTemplateColumns = ''; mainGrid.classList.remove('two-column-layout'); mainGrid.setAttribute('data-layout-mode', 'list'); }
      }

      requestAnimationFrame(() => {
        const lastPositions = new Map();
        items.forEach(item => { const rect = item.getBoundingClientRect(); lastPositions.set(item, { left: rect.left, top: rect.top }); });
        items.forEach(item => { const first = firstPositions.get(item); const last = lastPositions.get(item); if (first && last) { const dx = first.left - last.left; const dy = first.top - last.top; item.style.transition='none'; item.style.transform = `translate(${dx}px, ${dy}px)`; } });
        requestAnimationFrame(() => {
          items.forEach((item, index) => { setTimeout(() => { item.classList.add('anime-animating'); item.style.transition=''; item.style.transform=''; }, index * 20); });
          setTimeout(() => { items.forEach(item => { item.classList.remove('anime-animating'); item.style.transition=''; item.style.transform=''; }); }, 500 + items.length * 20);
        });
      });
    }

    window.addEventListener("layoutChange", (event) => { updateGamesListLayout(event.detail.layout); });
  })();
  </script>

  <!-- è¿‡æ»¤æŒ‰é’®æ ·å¼ & ç½‘æ ¼å®¹å™¨æ ·å¼ -->
  <style>
    .card-base { container-type: inline-size; }
    .games-grid-container { display: grid; grid-template-columns: repeat(2, 1fr); transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .games-grid-container.single-sidebar { @container (min-width: 900px) { grid-template-columns: repeat(5, 1fr); } @container (min-width: 600px) and (max-width: 899px) { grid-template-columns: repeat(3, 1fr); } @container (max-width: 599px) { grid-template-columns: repeat(2, 1fr); } }
    .games-grid-container.both-sidebar { @container (min-width: 950px) { grid-template-columns: repeat(5, 1fr); } @container (min-width: 650px) and (max-width: 949px) { grid-template-columns: repeat(4, 1fr); } @container (min-width: 480px) and (max-width: 649px) { grid-template-columns: repeat(3, 1fr); } @container (max-width: 479px) { grid-template-columns: repeat(2, 1fr); } }

    .filter-container { display:flex; flex-wrap:wrap; gap:0.5rem; }
    .filter-tag { padding:0.5rem 1rem; border:1px solid var(--line-divider); border-radius:var(--radius-large); background:var(--btn-regular-bg); color:var(--btn-content); font-size:0.875rem; font-weight:500; cursor:pointer; transition:all 0.2s ease; white-space:nowrap; }
    .filter-tag:hover:not(.active) { background:var(--btn-hover-bg); border-color:var(--primary); transform:translateY(-1px); }
    .filter-tag.active { background:var(--primary); color:#fff; border-color:var(--primary); }
    .filter-tag.active:hover { background:var(--primary)!important; color:#fff!important; border-color:var(--primary)!important; transform:translateY(-1px); }

    [data-game-status] { transition: all 0.5s cubic-bezier(0.4,0,0.2,1); }
    #games-list-container.grid-mode [data-game-status]:hover { transform: translateY(-8px) scale(1.02); box-shadow: 0 12px 24px rgba(0,0,0,0.15); z-index: 10; transition: all 0.3s cubic-bezier(0.4,0,0.2,1); }
    #games-list-container.list-mode [data-game-status]:hover { transform: translateX(8px) scale(1.01); box-shadow: 0 8px 16px rgba(0,0,0,0.1); z-index: 10; transition: all 0.3s cubic-bezier(0.4,0,0.2,1); }
    [data-game-status].anime-hidden { display:none; }
    [data-game-status].anime-animating { transition: transform 0.5s cubic-bezier(0.4,0,0.2,1), opacity 0.5s cubic-bezier(0.4,0,0.2,1); }
    [data-game-status].anime-fade-out { opacity:0; transform:scale(0.8); pointer-events:none; transition: opacity 0.3s cubic-bezier(0.4,0,0.2,1), transform 0.3s cubic-bezier(0.4,0,0.2,1); }
    [data-game-status].anime-fade-in { opacity:0; transform:scale(0.8); }
    [data-game-status].anime-fade-in-active { opacity:1; transform:scale(1); }
  </style>

  <!-- è¿‡æ»¤åŠŸèƒ½è„šæœ¬ï¼ˆFLIP åŠ¨ç”»ï¼‰ -->
  <script is:inline>
    let filterEventListeners = [];
    function initFilterButtons() {
      const filterTags = document.querySelectorAll('.filter-tag');
      filterEventListeners.forEach(([el, type, handler]) => el.removeEventListener(type, handler));
      filterEventListeners = [];

      filterTags.forEach(tag => {
        const clickHandler = function() {
          if (this.classList.contains('active')) return;
          filterTags.forEach(t => t.classList.remove('active'));
          this.classList.add('active');

          const status = this.getAttribute('data-status');
          const items = Array.from(document.querySelectorAll('[data-game-status]'));

          const firstPositions = new Map();
          items.forEach(item => { const rect = item.getBoundingClientRect(); firstPositions.set(item, { left: rect.left, top: rect.top, width: rect.width, height: rect.height }); });

          const itemsToHide = [], itemsToShow = [], itemsToKeep = [];
          items.forEach(item => {
            const itemStatus = item.getAttribute('data-game-status');
            const shouldShow = status === 'all' || itemStatus === status;
            const isVisible = !item.classList.contains('anime-hidden');
            if (shouldShow) { isVisible ? itemsToKeep.push(item) : itemsToShow.push(item); }
            else if (isVisible) { itemsToHide.push(item); }
          });

          itemsToHide.forEach(item => item.classList.add('anime-fade-out'));
          setTimeout(() => {
            itemsToHide.forEach(item => { item.classList.add('anime-hidden'); item.classList.remove('anime-fade-out'); });
            itemsToShow.forEach(item => { item.classList.remove('anime-hidden'); item.classList.add('anime-fade-in'); item.style.opacity='0'; item.style.transform='scale(0.8)'; item.style.transition='none'; });

            requestAnimationFrame(() => {
              const lastPositions = new Map();
              [...itemsToKeep, ...itemsToShow].forEach(item => { const rect = item.getBoundingClientRect(); lastPositions.set(item, { left: rect.left, top: rect.top }); });
              itemsToKeep.forEach(item => { const first = firstPositions.get(item); const last = lastPositions.get(item); if (first && last) { const dx = first.left - last.left; const dy = first.top - last.top; item.style.transition='none'; item.style.transform = `translate(${dx}px, ${dy}px)`; } });

              requestAnimationFrame(() => {
                const allItems = [...itemsToKeep, ...itemsToShow];
                allItems.forEach((item, index) => {
                  setTimeout(() => {
                    item.classList.add('anime-animating');
                    if (itemsToKeep.includes(item)) { item.style.transition=''; item.style.transform=''; }
                    if (itemsToShow.includes(item)) { item.classList.remove('anime-fade-in'); item.classList.add('anime-fade-in-active'); item.style.transition=''; item.style.opacity='1'; item.style.transform='scale(1)'; }
                  }, index * 20);
                });
                setTimeout(() => { allItems.forEach(item => { item.classList.remove('anime-animating','anime-fade-in-active'); item.style.transition=''; item.style.transform=''; item.style.opacity=''; }); }, 500 + allItems.length * 20);
              });
            });
          }, 300);
        };
        tag.addEventListener('click', clickHandler);
        filterEventListeners.push([tag, 'click', clickHandler]);
      });
    }
    document.addEventListener('DOMContentLoaded', initFilterButtons);
    function setupSwupListeners() {
      if (window.swup) {
        window.swup.hooks.on('content:replace', function() { setTimeout(initFilterButtons, 150); });
        window.swup.hooks.on('page:view', function() { setTimeout(initFilterButtons, 150); });
        window.swup.hooks.on('animation:in:end', function() { setTimeout(initFilterButtons, 200); });
      }
    }
    if (typeof window !== 'undefined') { if (window.swup) { setupSwupListeners(); } else { document.addEventListener('swup:enable', function() { setupSwupListeners(); }); } }
  </script>
</MainGridLayout>
